#!/usr/bin/env python3
""" 
segmentation.py: M칩dulo de segmentaci칩n.
"""


import os, sys
import glob
import numpy as np
import cv2
import cv2.ximgproc as ximg
import matplotlib as mpl
import matplotlib.pyplot as plt
import argparse
import torch
import random
import time

from mpl_toolkits.mplot3d import Axes3D
from segment_anything import SamAutomaticMaskGenerator, sam_model_registry

LIGHT_PURPLE = (213, 184, 255)
DARK_BLUE = (1, 1, 122)

def show_anns(anns):
    if len(anns) == 0:
        return
    sorted_anns = sorted(anns, key=(lambda x: x['area']), reverse=True)
    ax = plt.gca()
    ax.set_autoscale_on(False)
    for ann in sorted_anns:
        m = ann['segmentation']
        img = np.ones((m.shape[0], m.shape[1], 3))
        color_mask = np.random.random((1, 3)).tolist()[0]
        for i in range(3):
            img[:,:,i] = color_mask[i]
        ax.imshow(np.dstack((img, m*0.5)))

def showSAM(img, masks):
    """Show SAM segmentation over original image

    Parameters
    ----------
    img : array_like, shape (N,2)
        Original image
    masks : list
        list of segmentation masks generated by SAM

    """
    fig = plt.figure(figsize=(20,20))
    plt.imshow(img)
    show_anns(masks)
    plt.axis('off')
    plt.show()



def binarySegmentationDepth(points):
    """Get waterbody segmentation using depth estimation

    Parameters
    ----------
    points : array_like, shape (N,3)
        Array containing the set of points in 3D

    Returns
    -------
    img : array_like,
        Image with the waterbody segmentation

    """

    nrows,ncols = points.shape
    
    img = np.zeros((nrows,ncols,3), dtype=np.int32)
    
    for i in range(nrows):
        for j in range(ncols):
            if points[i,j] > 0.55:
                img[i,j] = LIGHT_PURPLE
            else:
                img[i,j] = DARK_BLUE
    
    return img



def getIntersectAndUnion(segment, segment_index, masks, thresh):
    """Calculates intersection and union values between 'segment' and 'thresh'"""

    intersection = 0
    union = 0
    
    # Merge all masks to obtain actual water segment
    segment_merged = np.zeros(segment['segmentation'].shape, dtype=np.int32)
    for i in range(segment_merged.shape[0]):
        for j in range(segment_merged.shape[1]):
            for m in range(len(masks)):
                if masks[m]['segmentation'][i,j]:
                    segment_merged[i,j] = m+1
    
    # Calculate intersection and union values
    for i in range(segment_merged.shape[0]):
        for j in range(segment_merged.shape[1]):
            if segment_merged[i,j] == segment_index+1:
                if thresh[i,j,:].tolist() == list(LIGHT_PURPLE):
                    intersection += 1
                union += 1

    return segment_merged, intersection, union



def segmentationSAM(depth, image_path):
    """Get the segmentation combining SAM with depth estimation. If possible, the function returns an object segmentation

    Parameters
    ----------
    depth : array_like, shape (N,3)
        Array containing the set of points in space
    image_path : str
        Image path

    Returns
    -------
    binary_mask : array_like
        Image with binary segmentation. If binary mask calculated with SAM does not segment water properly, depth based segmentation will be used.
    color_mask : array_like
        Image with object segmentation. If binary mask calculated with SAM does not segment water properly, color_mask will be None
    """
    
    img = cv2.imread(image_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    
    nrows_img, ncols_img, _ = img.shape

    # Segmentation with depth
    thresh = binarySegmentationDepth(depth)
    thresh = cv2.resize(thresh, (ncols_img,nrows_img), interpolation = cv2.INTER_LINEAR_EXACT)
    
    
    # Count water pixels 
    water = 0
    for i in range(nrows_img):
        for j in range(ncols_img):
            if thresh[i,j,:].tolist() == list(LIGHT_PURPLE):
                water += 1
    water_percent = water/(nrows_img*ncols_img)
    
    # Get SAM segmentation
    sam = sam_model_registry["vit_h"](checkpoint="vit_h.pth")
    mask_generator = SamAutomaticMaskGenerator(
        model=sam,
        points_per_side=32
    )
    masks = mask_generator.generate(img)
    masks = sorted(masks, key=(lambda x: x['area']), reverse=True)
    
    #showSAM(img, masks)
    
    # Select biggest segment as water
    segment_areas = [sub['area'] for sub in masks]
    water_segment_index = segment_areas.index(max(segment_areas))
    water_segment = masks[water_segment_index]
    
    water_segment_merged, intersection, union = getIntersectAndUnion(water_segment, water_segment_index, masks, thresh)
    
    # Check if selected water segment has a good "intersect over union" value
    while (intersection/union) < 0.4:
        # "Intersect over union" value is not good enough. Search for another water segment
        del segment_areas[water_segment_index]
        if len(segment_areas) == 0:
            print('Intersection over union is not good enough for any mask. Segmentation based on depth estimation will be used')
            return thresh, None
        water_segment_index = segment_areas.index(max(segment_areas))
        water_segment = masks[water_segment_index]
        
        water_segment_merged, intersection, union = getIntersectAndUnion(water_segment, water_segment_index, masks, thresh)
        
    union += (water - intersection)

    color_mask = img.copy()
    binary_mask = img.copy()
    
        
    # Defining random colors
    colors = []
    for i in range(len(masks)):
        for j in range(3):
            colors.append(list(np.random.choice(range(255),size=3)))
    
    water = 0

    # Create binary and color masks
    for i in range(water_segment_merged.shape[0]):
        for j in range(water_segment_merged.shape[1]):
            if water_segment_merged[i,j] == water_segment_index+1:
                color_mask[i,j] = LIGHT_PURPLE
                binary_mask[i,j] = LIGHT_PURPLE
                water +=1
            else:  
                color_mask[i,j] = colors[water_segment_merged[i,j]]
                binary_mask[i,j] = DARK_BLUE

    water_percent_SAM = water/(water_segment_merged.shape[0]*water_segment_merged.shape[1])

    if water_percent_SAM/water_percent < 0.5:
        print('No se ha encontrado una m치scara binaria mejor. Se utiliza la calculada a partir de la estimaci칩n de profundidad')
        return thresh, None
    
    return binary_mask, color_mask



def binarySegmentationSuperpixels(image_path):
    """Show binary segmentation based on HSV range colors using superpixels

    Parameters
    ----------
    image_path : str
        Image path

    """

    # Read image path
    img = cv2.imread(image_path)

    # Convert to HSV color space
    hsv_image= cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # SEEDS parameters
    height,width,channels = hsv_image.shape
    num_iterations = 500
    prior = 5
    num_superpixels = 800
    num_levels = 20
    num_histogram_bins = 5


    seeds = cv2.ximgproc.createSuperpixelSEEDS(width, height, channels, num_superpixels, num_levels, prior, num_histogram_bins)
    color_img = np.zeros((height,width,3), np.uint8)
    color_img[:] = (0, 0, 255)

    # Iterate until segmentation is done
    seeds.iterate(img, num_iterations)

    # Get the labels for each pixel
    labels = seeds.getLabels()

    superpixel_mask = seeds.getLabelContourMask(False)

    # stitch foreground & background together
    mask_inv = cv2.bitwise_not(superpixel_mask)
    result_bg = cv2.bitwise_and(img, img, mask=mask_inv)
    result_fg = cv2.bitwise_and(color_img, color_img, mask=superpixel_mask)
    result = cv2.add(result_bg, result_fg)

    # Create an empty image to draw the superpixel segments
    output = np.zeros_like(img)

    # Define HSV blue range
    lower_blue = np.array([97,170,70])
    upper_blue= np.array([130,255,255])

    # Define HSV white range
    lower_white = np.array([0,0,150])
    upper_white = np.array([180,255,255])

    # Loop over each superpixel and color it in either light purple or dark blue
    for i in range(num_superpixels):
        mask = labels == i
        if (np.count_nonzero((hsv_image[mask] >= lower_blue).all(axis=1) & (hsv_image[mask] <= upper_blue).all(axis=1)) >= len(hsv_image[mask])) or (np.count_nonzero((hsv_image[mask] >= lower_white).all(axis=1) & (hsv_image[mask] <= upper_white).all(axis=1)) >= len(hsv_image[mask])):
            output[mask] = LIGHT_PURPLE
        else:
            output[mask] = DARK_BLUE


    cv2.imshow('superpixels', result)
    cv2.waitKey(0)

    # Show image
    cv2.imshow('Superpixel segmentation', output)
    cv2.waitKey(0)
    cv2.destroyAllWindows()



def applyMask(mask, points, coloring):
    """Apply skyline mask to pointcloud

    Parameters
    ----------
    mask : array_like, shape (nrows, ncols, 3)
        Segmentation mask
    points : array_like, shape (N,3)
        Array containing the set of points in space

    Returns
    -------
    point_array : array_like 
        Resulting array after deleting water pixels

    """
    
    nrows,ncols = points.shape
    
    points_mask = points.copy()
    
    delete_counter = 0
    
    for i in range(nrows):
        for j in range(ncols):
            if mask[i,j,:].tolist() == list(LIGHT_PURPLE):
                points_mask[i,j] = 1
                delete_counter += 1
                
    useful = nrows*ncols - delete_counter
                
    point_array = np.zeros(shape=(useful,3))
    colors = np.array(np.zeros(shape=(useful,3)))
    
    
    i = 0
    for x in range(nrows):
        for y in range(ncols):
            if points_mask[x,y] < 0.9:
                point_array[i] = [x,y,points_mask[x,y]]
                if coloring == 'objects':
                    colors[i] = [val/255.0 for val in mask[x,y,:].tolist()]
                elif coloring == 'binary':
                    colors[i] = [val/255.0 for val in list(DARK_BLUE)]
                i += 1
    
    if coloring == 'depth':
        colors = point_array[:, 2]
    
    return point_array, colors
                


def showSegmentations(binary_mask, depth, pc_color, color_mask=None):

    # Resize mask
    nrows,ncols = depth.shape
    binaryMask_resized = cv2.resize(binary_mask, (ncols,nrows), interpolation = cv2.INTER_AREA)

    if color_mask is None:
        ncols_plot = 2
        pc_color = 'depth'
        pc_mask, colors = applyMask(binaryMask_resized, depth, coloring=pc_color)

    else:
        colorMask_resized = cv2.resize(color_mask, (ncols,nrows), interpolation = cv2.INTER_AREA)
        ncols_plot = 3
        pc_mask, colors = applyMask(colorMask_resized, depth, pc_color)

    

    # Plot segmentation
    fig = plt.figure(figsize=plt.figaspect(0.5))
        
    # ===========================
    # First subplot (binary mask)
    # ===========================
    # set up the axes for the first plot
    ax = fig.add_subplot(1, ncols_plot, 1)
    ax.set_title('Binary segmentation')
    ax.imshow(binaryMask_resized)

    if color_mask is not None:
        # ===========================
        # Second subplot (color mask)
        # ===========================
        # set up the axes for the second plot
        ax = fig.add_subplot(1, ncols_plot, 2)
        ax.set_title('Object segmentation')
        ax.imshow(colorMask_resized)
    
    # ==============
    # Third subplot
    # ==============
    # set up the axes for the second plot
    ax = fig.add_subplot(1, ncols_plot, ncols_plot, projection='3d')
    ax.set_title('3D pointcloud')
    
    if pc_color == 'objects' or pc_color == 'binary':
        ax.scatter(
            pc_mask[:, 1],
            pc_mask[:, 2],
            pc_mask[:, 0],
            s=0.03,
            c=colors
        )
    else:
        cmap="jet_r"
        ax.scatter(
            pc_mask[:, 1],
            pc_mask[:, 2],
            pc_mask[:, 0],
            s=0.03,
            c=colors,
            cmap=cmap
        )
    ax.view_init(0,270)
    if ncols_plot == 3:
        ax.dist = 7

    ax.set_xlim3d(0, ncols)
    ax.set_ylim3d(np.amin(pc_mask[:,2]), np.amax(pc_mask[:,2]))
    ax.set_zlim3d(0, nrows)

    ax.invert_zaxis()
    plt.show()
