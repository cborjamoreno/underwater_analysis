#!/usr/bin/env python3

""" 
segmentation.py: M칩dulo de segmentaci칩n.
"""


import numpy as np
import cv2
import matplotlib as mpl
import matplotlib.pyplot as plt
import time

from segment_anything import SamAutomaticMaskGenerator, sam_model_registry

LIGHT_PURPLE = (213, 184, 255)
DARK_BLUE = (1, 1, 122)

def showSAM(img, masks):
    """Show SAM segmentation over original image

    Parameters
    ----------
    img : array_like, shape (N,2)
        Original image
    masks : list
        list of segmentation masks generated by SAM

    """

    fig = plt.figure(figsize=(20,20))
    plt.imshow(img)

    if len(masks) == 0:
        return
    sorted_anns = sorted(masks, key=(lambda x: x['area']), reverse=True)
    ax = plt.gca()
    ax.set_autoscale_on(False)
    for ann in sorted_anns:
        m = ann['segmentation']
        img = np.ones((m.shape[0], m.shape[1], 3))
        color_mask = np.random.random((1, 3)).tolist()[0]
        for i in range(3):
            img[:,:,i] = color_mask[i]
        ax.imshow(np.dstack((img, m*0.5)))

    plt.axis('off')
    plt.show()



def binarySegmentationDepth(points):
    """Get waterbody segmentation using depth estimation

    Parameters
    ----------
    points : array_like, shape (N,3)
        Array containing the set of points in 3D

    Returns
    -------
    img : array_like,
        Image with the waterbody segmentation

    """

    nrows,ncols = points.shape
    
    img = np.zeros((nrows,ncols,3), dtype=np.int32)
    
    for i in range(nrows):
        for j in range(ncols):
            if points[i,j] > 0.55:
                img[i,j] = LIGHT_PURPLE
            else:
                img[i,j] = DARK_BLUE
    
    return img



def segmentationSAM(depth, image_path):
    """Get the segmentation combining SAM with depth estimation. If possible, the function returns an object segmentation

    Parameters
    ----------
    depth : array_like, shape (N,3)
        Array containing the set of points in space
    image_path : str
        Image path

    Returns
    -------
    binary_mask : array_like
        Image with binary segmentation. If binary mask calculated with SAM does not segment water properly, depth based segmentation will be used.
    color_mask : array_like
        Image with object segmentation. If binary mask calculated with SAM does not segment water properly, color_mask will be None
    """


    def getIntersectAndUnion(segment, segment_index, masks, thresh):
        """Calculates intersection and union values between 'segment' and 'thresh'"""

        intersection = 0
        union = 0
        
        # Merge all masks to obtain actual water segment
        segment_merged = np.zeros(segment['segmentation'].shape, dtype=np.int32)
        for i in range(segment_merged.shape[0]):
            for j in range(segment_merged.shape[1]):
                for m in range(len(masks)):
                    if masks[m]['segmentation'][i,j]:
                        segment_merged[i,j] = m+1
        
        # Calculate intersection and union values
        for i in range(segment_merged.shape[0]):
            for j in range(segment_merged.shape[1]):
                if segment_merged[i,j] == segment_index+1:
                    if thresh[i,j,:].tolist() == list(LIGHT_PURPLE):
                        intersection += 1
                    union += 1

        return segment_merged, intersection, union
    

    
    img = cv2.imread(image_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    
    nrows_img, ncols_img, _ = img.shape

    # Segmentation with depth
    thresh = binarySegmentationDepth(depth)
    thresh = cv2.resize(thresh, (ncols_img,nrows_img), interpolation = cv2.INTER_LINEAR_EXACT)
    
    
    # Count water pixels 
    water = 0
    for i in range(nrows_img):
        for j in range(ncols_img):
            if thresh[i,j,:].tolist() == list(LIGHT_PURPLE):
                water += 1
    water_percent = water/(nrows_img*ncols_img)
    
    # Get SAM segmentation
    sam = sam_model_registry["vit_h"](checkpoint="vit_h.pth")
    mask_generator = SamAutomaticMaskGenerator(
        model=sam,
        points_per_side=32
    )
    masks = mask_generator.generate(img)
    masks = sorted(masks, key=(lambda x: x['area']), reverse=True)
    
    #showSAM(img, masks)
    
    # Select biggest segment as water
    segment_areas = [sub['area'] for sub in masks]
    water_segment_index = segment_areas.index(max(segment_areas))
    water_segment = masks[water_segment_index]
    
    water_segment_merged, intersection, union = getIntersectAndUnion(water_segment, water_segment_index, masks, thresh)
    
    # Check if selected water segment has a good "intersect over union" value
    while (intersection/union) < 0.4:
        # "Intersect over union" value is not good enough. Search for another water segment
        del segment_areas[water_segment_index]
        if len(segment_areas) == 0:
            print('Intersection over union is not good enough for any mask. Segmentation based on depth estimation will be used')
            return thresh, None
        water_segment_index = segment_areas.index(max(segment_areas))
        water_segment = masks[water_segment_index]
        
        water_segment_merged, intersection, union = getIntersectAndUnion(water_segment, water_segment_index, masks, thresh)
        
    union += (water - intersection)

    color_mask = img.copy()
    binary_mask = img.copy()
    
        
    # Defining random colors
    colors = []
    for i in range(len(masks)):
        for j in range(3):
            colors.append(list(np.random.choice(range(255),size=3)))
    
    water = 0

    # Create binary and color masks
    for i in range(water_segment_merged.shape[0]):
        for j in range(water_segment_merged.shape[1]):
            if water_segment_merged[i,j] == water_segment_index+1:
                color_mask[i,j] = LIGHT_PURPLE
                binary_mask[i,j] = LIGHT_PURPLE
                water +=1
            else:  
                color_mask[i,j] = colors[water_segment_merged[i,j]]
                binary_mask[i,j] = DARK_BLUE

    water_percent_SAM = water/(water_segment_merged.shape[0]*water_segment_merged.shape[1])

    if water_percent_SAM/water_percent < 0.5:
        print('No se ha encontrado una m치scara binaria mejor. Se utiliza la calculada a partir de la estimaci칩n de profundidad')
        return thresh, None
    
    return binary_mask, color_mask



def binarySegmentationSuperpixels(image_path):
    """Shows binary segmentation based on HSV range colors using superpixels

    Parameters
    ----------
    image_path : str
        Image path
    """

    # Read image path
    img = cv2.imread(image_path)

    # Convert to HSV color space
    hsv_image= cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # SEEDS parameters
    height,width,channels = hsv_image.shape
    num_iterations = 500
    prior = 5
    num_superpixels = 800
    num_levels = 20
    num_histogram_bins = 5


    seeds = cv2.ximgproc.createSuperpixelSEEDS(width, height, channels, num_superpixels, num_levels, prior, num_histogram_bins)
    color_img = np.zeros((height,width,3), np.uint8)
    color_img[:] = (0, 0, 255)

    # Iterate until segmentation is done
    seeds.iterate(img, num_iterations)

    # Get the labels for each pixel
    labels = seeds.getLabels()

    superpixel_mask = seeds.getLabelContourMask(False)

    # Stitch foreground & background together
    mask_inv = cv2.bitwise_not(superpixel_mask)
    result_bg = cv2.bitwise_and(img, img, mask=mask_inv)
    result_fg = cv2.bitwise_and(color_img, color_img, mask=superpixel_mask)
    result = cv2.add(result_bg, result_fg)

    # Create an empty image to draw the superpixel segments
    output = np.zeros_like(img)

    # Define HSV blue range
    lower_blue = np.array([97,170,70])
    upper_blue= np.array([130,255,255])

    # Define HSV white range
    lower_white = np.array([0,0,150])
    upper_white = np.array([180,255,255])

    # Loop over each superpixel and color it in either light purple or dark blue
    for i in range(num_superpixels):
        mask = labels == i
        if (np.count_nonzero((hsv_image[mask] >= lower_blue).all(axis=1) & (hsv_image[mask] <= upper_blue).all(axis=1)) >= len(hsv_image[mask])) or (np.count_nonzero((hsv_image[mask] >= lower_white).all(axis=1) & (hsv_image[mask] <= upper_white).all(axis=1)) >= len(hsv_image[mask])):
            output[mask] = LIGHT_PURPLE
        else:
            output[mask] = DARK_BLUE


    cv2.imshow('superpixels', result)
    cv2.waitKey(0)

    # Show image
    cv2.imshow('Superpixel segmentation', output)
    cv2.waitKey(0)
    cv2.destroyAllWindows()



def showSegmentation(depth, binary_mask, color_mask=None):
    """Shows both binary and object segmentation images.

    Parameters
    ----------
    depth : array_like, shape (N,3)
        Array containing the set of points in space
    binary_mask : array_like, shape (nrows, ncols, 3)
        Binary segmentation mask
    color_mask : array_like, shape (nrows, ncols, 3)
        Object segmentation mask. If color_mask is None, object segmentation is not shown

    """

    # Resize mask
    nrows,ncols = depth.shape
    binaryMask_resized = cv2.resize(binary_mask, (ncols,nrows), interpolation = cv2.INTER_AREA)

    if color_mask is None:
        ncols_plot = 1

    else:
        colorMask_resized = cv2.resize(color_mask, (ncols,nrows), interpolation = cv2.INTER_AREA)
        ncols_plot = 2

    # Plot segmentation
    fig = plt.figure(figsize=plt.figaspect(0.5))
        
    # ===========================
    # First subplot (binary mask)
    # ===========================
    # set up the axes for the first plot
    ax = fig.add_subplot(1, ncols_plot, 1)
    ax.set_title('Binary segmentation')
    ax.imshow(binaryMask_resized)

    if color_mask is not None:

        # ===========================
        # Second subplot (color mask)
        # ===========================
        # set up the axes for the second plot
        ax = fig.add_subplot(1, ncols_plot, 2)
        ax.set_title('Object segmentation')
        ax.imshow(colorMask_resized)
    
    plt.show()


def evaluate(eval_path, mask):
    """Evaluate 'mask' with mask located in 'eval_path'. The function calculates TP, FP, TN, FN. Water pixels must be labeled as RGB (0,0,0) in mask located in 'eval_path'.

    Parameters
    ----------
    eval_path : str
        Path to evaluation mask
    mask : array_like
        Segmentation mask to evaluate

    Returns
    -------
    TP : int
        True positives
    FP : int
        False positives
    TN : int
        True negatives
    FN : int
        False negatives

    """

    # Load evaluation mask
    eval_mask = cv2.imread(eval_path)
    eval_mask = cv2.cvtColor(eval_mask, cv2.COLOR_BGR2RGB)

    # mask = cv2.cvtColor(mask, cv2.COLOR_BGR2RGB)

    c = (0,0,0) # Black
    indices = np.where(np.all(eval_mask == c, axis=-1))
    water_GT = list(zip(indices[0], indices[1]))
    
    indices = np.where(np.any(eval_mask != c, axis=-1))
    not_water_GT = list(zip(indices[0], indices[1]))

    TP = 0
    FP = 0
    TN = 0
    FN = 0

    for p in water_GT:
        if mask[p[0],p[1],:].tolist() == list(LIGHT_PURPLE):
            TP +=1 
        else:
            FN +=1
    
    for p in not_water_GT:
        if mask[p[0],p[1],:].tolist() != list(LIGHT_PURPLE):
            TN +=1
        else:
            FP +=1
    
    return TP, FP, TN, FN