#!/usr/bin/env python3

""" 
segmentation.py: Módulo de segmentación.
"""


import numpy as np
import cv2
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import time
from sklearn.cluster import DBSCAN
from PIL import Image
from scipy.ndimage import sobel
from skimage import feature

from segment_anything import SamAutomaticMaskGenerator, sam_model_registry
from modules.Module3D.depth_estimation import estimate

LIGHT_PURPLE = (213, 184, 255)
DARK_BLUE = (1, 1, 122)

def showSAM(img, masks, output_path=None):
    """Show SAM segmentation over original image

    Parameters
    ----------
    img : array_like, shape (N,2)
        Original image
    masks : list
        list of segmentation masks generated by SAM

    """

    fig = plt.figure(figsize=(20,20))
    plt.imshow(img)

    masks

    if len(masks) == 0:
        return
    sorted_anns = sorted(masks, key=(lambda x: x['area']), reverse=True)
    ax = plt.gca()
    ax.set_autoscale_on(False)
    for ann in sorted_anns:
        m = ann['segmentation']
        img = np.ones((m.shape[0], m.shape[1], 3))
        color_mask = np.random.random((1, 3)).tolist()[0]
        for i in range(3):
            img[:,:,i] = color_mask[i]
        ax.imshow(np.dstack((img, m*0.5)))

    plt.axis('off')
    if output_path:
        plt.savefig(output_path)
    plt.show()

def binarySegmentationDepth(depth, threshold_multiplier=0.8):
    """Get waterbody binary segmentation using a dynamically calculated threshold based on gradient magnitude

    Parameters
    ----------
    depth : numpy array, shape (nrows, ncols)
        Depth estimation
    threshold_multiplier : float, optional
        Multiplier for the threshold calculated based on the maximum depth (default is 0.9)

    Returns
    -------
    img : array_like
        Image with the waterbody binary segmentation
    """

    # Set the threshold to be a certain percentage of the maximum depth value
    threshold = threshold_multiplier * np.max(depth)

    # Create 3D arrays for the colors
    nrows, ncols = depth.shape
    LIGHT_PURPLE_3D = np.full((nrows, ncols, 3), LIGHT_PURPLE)
    DARK_BLUE_3D = np.full((nrows, ncols, 3), DARK_BLUE)

    # Color the water body
    img = np.where(depth[..., np.newaxis] > threshold, LIGHT_PURPLE_3D, DARK_BLUE_3D)
    
    return img

def showBinarySegmentationDepth(image_path, output_path=None):
    """Show waterbody segmentation using depth estimation

    Parameters
    ----------
    image_path : str
        Image path

    Returns
    -------
    img : array_like,
        Image with the waterbody segmentation

    """

    img = cv2.imread(image_path)
    nrows,ncols,_ = img.shape

    # Estimate depth for image
    points = estimate(image_path)

    mask = binarySegmentationDepth(points).astype(np.uint8)

    # Resize mask
    mask_resized = cv2.resize(mask, (ncols,nrows), interpolation = cv2.INTER_AREA)


    plt.imshow(mask_resized)

    legend_data = [
        [127,list(LIGHT_PURPLE),"water"],
        [126,list(DARK_BLUE),"scene"]
    ]
    handles = [
        Rectangle((0,0),1,1, color = [v/255 for v in c]) for k,c,n in legend_data
    ]
    labels = [n for k,c,n in legend_data]


    # Show image
    plt.grid(False)
    plt.axis('off')
    # plt.legend(handles,labels)
    if output_path:
        plt.savefig(output_path)
    plt.show(block=False)
    plt.close('all')
    
    return mask_resized

def floatingSegmentation(binary_mask):
    """Get floating objects segmentation

    Parameters
    ----------
    binary_mask : array_like
        Image with binary segmentation.

    Returns
    -------
    img : array_like,
        Image with the floating objects segmentation
    """

    def is_floating(component_mask):
        """Check if a component is a floating object

        Parameters
        ----------
        component_mask : array_like
            Binary mask of the component.

        Returns
        -------
        bool
            True if the component is a floating object, False otherwise.
        """
        if np.sum(component_mask[-1, :]) == 0:
            return True
        else:
            return False

    # Convert the binary mask to grayscale if it's not already
    gray_img = cv2.cvtColor(binary_mask, cv2.COLOR_BGR2GRAY)

    # show binary mask
    # cv2.imshow('Contours', binary_mask)
    # cv2.waitKey(0)

    # Apply a 7x7 Gaussian blur
    blurred = cv2.GaussianBlur(gray_img, (7, 7), 0)

    # Applying threshold 
    threshold = cv2.threshold(blurred, 0, 255, 
    cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]

    # Apply the Component analysis function 
    analysis = cv2.connectedComponentsWithStats(threshold, 
                                                4,
                                                cv2.CV_32S) 
    (totalLabels, label_ids, values, centroid) = analysis 

    # Use binary_mask as the output image
    output = binary_mask.copy()

    # Loop through each component 
    for i in range(1, totalLabels): 
        # If the component is a floating point
        if is_floating(analysis[1] == i):
            # Create the mask
            mask = (analysis[1] == i).astype("uint8")
            # Apply the mask to the appropriate channels
            output[mask == 1] = (0, 128, 90)
            # output[mask == 1] = DARK_BLUE

    # cv2.imshow("Filtered Components", output) 
    # cv2.waitKey(0)

    return output
    
def showFloatingSegmentation(binary_mask):
    """Show floating objects segmentation

    Parameters
    ----------
    binary_mask : array_like
        Image with binary segmentation.

    Returns
    -------
    img : array_like,
        Image with the floating objects segmentation

    """

    result = floatingSegmentation(binary_mask)

    plt.imshow(result)

    legend_data = [
        [127,list(LIGHT_PURPLE),"water"],
        [126,list(DARK_BLUE),"scene"],
        [125,list([0,128,90]),"floating"]
    ]
    handles = [
        Rectangle((0,0),1,1, color = [v/255 for v in c]) for k,c,n in legend_data
    ]
    labels = [n for k,c,n in legend_data]


    # Show image
    plt.grid(False)
    plt.axis('off')
    # plt.legend(handles,labels)
    plt.show()

    
    return result

def segmentationSAM(img):
    """Get the segmentation of an image with SAM

    Parameters
    ----------
    img : array_like, shape (rows,cols,3)
        Image to segment

    Returns
    -------
    masks : list of masks
        List of segmentation masks found by SAM in the image where each mask is a dictionary with the following fields:
            - segmentation : the mask
            - area : the area of the mask in pixels
            - bbox : the boundary box of the mask in XYWH format
            - predicted_iou : the model's own prediction for the quality of the mask
            - point_coords : the sampled input point that generated this mask
            - stability_score : an additional measure of mask quality
            - crop_box : the crop of the image used to generate this mask in XYWH format
    """

    device = "cuda"

    sam = sam_model_registry["vit_h"](checkpoint="modules/vit_h.pth")
    sam.to(device=device)
    mask_generator = SamAutomaticMaskGenerator(
        model=sam,
        points_per_side=32
    )
    masks = mask_generator.generate(img)

    return masks

def binarySegmentationSuperpixels(img):
    """Get binary segmentation based on HSV range colors using superpixels

    Parameters
    ----------
    img : array_like, shape (rows,cols,3)
        Image to segment

    Returns
    -------
    mask : array_like
        Image with binary segmentation.
    """

    # Convert to HSV color space
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    hsv_image= cv2.cvtColor(img, cv2.COLOR_RGB2HSV)

    # SEEDS parameters
    height,width,channels = hsv_image.shape
    num_iterations = 500
    prior = 5
    num_superpixels = 800
    num_levels = 20
    num_histogram_bins = 5


    seeds = cv2.ximgproc.createSuperpixelSEEDS(width, height, channels, num_superpixels, num_levels, prior, num_histogram_bins)
    color_img = np.zeros((height,width,3), np.uint8)
    color_img[:] = (0, 0, 255)

    # Iterate until segmentation is done
    seeds.iterate(img, num_iterations)

    # Get the labels for each pixel
    labels = seeds.getLabels()

    superpixel_mask = seeds.getLabelContourMask(False)

    # Stitch foreground & background together
    mask_inv = cv2.bitwise_not(superpixel_mask)
    result_bg = cv2.bitwise_and(img, img, mask=mask_inv)
    result_fg = cv2.bitwise_and(color_img, color_img, mask=superpixel_mask)
    result = cv2.add(result_bg, result_fg)

    # Create an empty image to draw the superpixel segments
    output = np.zeros_like(img)

    # Define HSV blue range
    lower_blue = np.array([87,150,150])
    upper_blue= np.array([130,255,255])

    # Define HSV white range
    lower_white = np.array([0,0,220])
    upper_white = np.array([180,255,255])

    # Loop over each superpixel and color it in either light purple or dark blue
    for i in range(num_superpixels):
        mask = labels == i
        superpixel_color = np.mean(hsv_image[mask], axis=0)  # Calcula la media del color del superpíxel

        if np.all(superpixel_color >= lower_blue) and np.all(superpixel_color <= upper_blue):
            output[mask] = LIGHT_PURPLE
        elif np.all(superpixel_color >= lower_white) and np.all(superpixel_color <= upper_white):
            output[mask] = LIGHT_PURPLE
        else:
            output[mask] = DARK_BLUE

    # Convert output from BGR to RGB for visualization
    output = cv2.cvtColor(output, cv2.COLOR_BGR2RGB)

    # cv2.imshow('superpixels', result)
    # cv2.waitKey(0)

    return output

def showBinarySegmentationSuperpixels(image_path, output_path=None):
    """Shows binary segmentation based on HSV range colors using superpixels

    Parameters
    ----------
    image_path : str
        Image path

    Returns
    -------
    output : array_like
        Image with binary segmentation.
    """

    # Read image path
    img = cv2.imread(image_path)
    mask = binarySegmentationSuperpixels(img)
    mask = cv2.cvtColor(mask, cv2.COLOR_BGR2RGB)

    plt.imshow(mask)

    legend_data = [
        [127,list(LIGHT_PURPLE),"water"],
        [126,list(DARK_BLUE),"scene"]
    ]
    handles = [
        Rectangle((0,0),1,1, color = [v/255 for v in c]) for k,c,n in legend_data
    ]
    labels = [n for k,c,n in legend_data]


    # Show image
    plt.grid(False)
    plt.axis('off')
    # plt.legend(handles,labels)
    if output_path:
        plt.savefig(output_path)
    plt.show(block=False)
    plt.close('all')

    return mask

def evaluate(eval_path, mask):
    """Evaluate 'mask' with mask located in 'eval_path'. The function calculates TP, FP, TN, FN. Water pixels must be labeled as RGB (0,0,0) in mask located in 'eval_path'.

    Parameters
    ----------
    eval_path : str
        Path to evaluation mask
    mask : array_like
        Segmentation mask to evaluate

    Returns
    -------
    TP : int
        True positives
    FP : int
        False positives
    TN : int
        True negatives
    FN : int
        False negatives

    """

    # Load evaluation mask
    # if eval_path is .bmp
    if eval_path.endswith(".bmp"):
        eval_mask = np.array(Image.open(eval_path))
    else:
        eval_mask = cv2.imread(eval_path)
        eval_mask = cv2.cvtColor(eval_mask, cv2.COLOR_BGR2RGB)

    c = (0,0,0) # Black
    indices = np.where(np.all(eval_mask == c, axis=-1))
    water_GT = list(zip(indices[0], indices[1]))
    
    indices = np.where(np.any(eval_mask != c, axis=-1))
    not_water_GT = list(zip(indices[0], indices[1]))

    TP = 0
    FP = 0
    TN = 0
    FN = 0

    for p in water_GT:
        if mask[p[0],p[1],:].tolist() == list(LIGHT_PURPLE):
            TP +=1 
        else:
            FN +=1
    
    for p in not_water_GT:
        if mask[p[0],p[1],:].tolist() != list(LIGHT_PURPLE):
            TN +=1
        else:
            FP +=1
    
    return TP, FP, TN, FN
